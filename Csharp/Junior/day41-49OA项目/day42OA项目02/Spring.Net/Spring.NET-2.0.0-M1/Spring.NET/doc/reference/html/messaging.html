<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;31.&nbsp;Message Oriented Middleware - Apache ActiveMQ and TIBCO EMS</title><link rel="stylesheet" href="styles/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot_8103"><link rel="home" href="index.html" title="The Spring.NET Framework"><link rel="up" href="spring-integration.html" title="Part&nbsp;V.&nbsp;Integration"><link rel="prev" href="spring-integration.html" title="Part&nbsp;V.&nbsp;Integration"><link rel="next" href="messaging-ems.html" title="Chapter&nbsp;32.&nbsp;Message Oriented Middleware - TIBCO EMS"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="background-color:white;border:none;height:73px;border:1px solid black;"><a style="border:none;" href="http://www.springframework.net/" title="The Spring Framework"><img style="border:none;" src="images/xdev-spring_logo.jpg"></img></a><a style="border:none;" href="http://www.springsource.com/" title="SpringSource"><img style="border:none;position:absolute;padding-top:5px;right:42px;" src="images/S2-banner-rhs.png"></img></a></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="messaging"></a>Chapter&nbsp;31.&nbsp;Message Oriented Middleware - Apache ActiveMQ and TIBCO EMS</h2></div></div></div>
  

  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e8686"></a>31.1.&nbsp;Introduction</h2></div></div></div>
    

    <p>The goal of Spring's messaging is to increase your productiviity
    when writing an enterprise strength messaging middleware applications.
    Spring achieves these goals in several ways. First it provides several
    helper classes that remove from the developer the incidental complexity
    and resource management issues that arise when using messaging APIs.
    Second, the design of these messaging helper classes promote best
    practices in designing a messaging application by promoting a clear
    separation between the messaging middleware specific code and business
    processing that is technology agnostic. This is generally referred to a
    "plain old CLR object" (or POCO) programming model.</p>

    <p>This chapter discusses Spring's messaging support for providers
    whose API was modeled after the Java Message Service (JMS) API. Vendors
    who provide a JMS inspired API include Apache ActiveMQ, TIBCO, IBM, and
    Progress Software. If you are using Microsoft's Message Queue, please
    refer to the specific <a class="link" href="msmq.html" title="Chapter&nbsp;33.&nbsp;Message Oriented Middleware - MSMQ">MSMQ section</a>. The
    description of Spring messages features in this chapter apply to all of
    these JMS vendors. However, the documentation focuses on showing code
    examples that use Apache ActiveMQ. For code examples and some features
    specific to TIBCO EMS please refer to <a class="link" href="messaging-ems.html" title="Chapter&nbsp;32.&nbsp;Message Oriented Middleware - TIBCO EMS">this</a> chapter.</p>

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="activemq-multi-vendor"></a>31.1.1.&nbsp;Multiple Vendor Support</h3></div></div></div>
      

      <p>As there is no de facto-standard common API across messaging
      vendors, Spring provides an implementation of its helper classes for
      each of the major messaging middleware vendors. The naming of the
      classes you will interact with most frequently will either be identical
      for each provider, but located in a different namespace, or have their
      prefix change to be the three-letter-acronym commonly associated with
      the message provider. The list of providers supported by Spring is show
      below along with their namespace and prefix.</p>

      <div class="orderedlist"><ol type="1"><li>
          <p>Apache ActiveMQ (NMS) in namespace
          <code class="literal">Spring.Messaging.Nms</code>. 'Nms' is used as the class
          prefix</p>
        </li><li>
          <p>TIBCO EMS in namespace
          <code class="literal">Spring.Messaging.Ems</code>. 'Ems' is used as the class
          prefix.</p>
        </li><li>
          <p>Websphere MQ in namespace
          <code class="literal">Spring.Messaging.Xms</code>, 'Xms' is used as the class
          prefix (in a future release)</p>
        </li></ol></div>

      <p>JMS can be roughly divided into two areas of functionality, namely
      the production and consumption of messages. For message production and
      the synchronous consumption of messages the a template class, named
      <code class="literal">NmsTemplate</code>, <code class="literal"> EmsTemplate</code> (etc.)
      is used. Asynchronous message consumption is performed though a
      multi-threaded message listener container,
      <code class="literal">SimpleMessageListenerContainer</code>. This message listener
      container is used to create Message-Driven POCOs (MDPs) which refer to a
      messaging callback class that consists of just 'plain CLR object's and
      is devoid of any specific messaging types or other artifacts. The
      <code class="literal">IMessageConverter</code> interface is used by both the
      template class and the message listener container to convert between
      provider message types and POCOs.</p>

      <p>The namespace
      <code class="literal">Spring.Messaging.&lt;Vendor&gt;.Core</code> contains the
      messing template class (e.g. <code class="literal">NmsTemplate</code>). The
      template class simplifies the use of the messaging APIs by handling the
      creation and release of resources, much like the
      <code class="literal">AdoTemplate</code> does for ADO.NET. The JMS inspired APIs
      are low-level API, much like ADO.NET. As such, even the simplest of
      operations requires 10s of lines of code with the bulk of that code
      related to resource management of intermediate API objects Spring's
      messaging support, both in Java and .NET, addresses the error-prone
      boiler plate coding style one needs when using these APIs.</p>

      <p>The design principle common to Spring template classes is to
      provide helper methods to perform common operations and for more
      sophisticated usage, delegate the essence of the processing task to user
      implemented callback interfaces. The messaging template follows the same
      design. The message template class offer various convenience methods for
      the sending of messages, consuming a message synchronously, and exposing
      the message Session and MessageProducer to the user.</p>

      <p>The namespace
      <code class="literal">Spring.Messaging.&lt;VendorAcronym&gt;.Support.Converter</code>
      provides a <code class="literal">IMessageConverter</code> abstraction to convert
      between .NET objects and messages. The namespace
      <code class="literal">Spring.Messaging.&lt;VendorAcronym&gt;.Support.Destinations</code>
      provides various strategies for managing destinations, such as providing
      a service locater for destinations stored in a directory service.</p>

      <p>Finally, the namespace
      <code class="literal">Spring.Messaging.&lt;VendorAcronym&gt;.Connections</code>
      provides an implementations of the ConnectionFactory suitable for use in
      standalone applications.</p>

      <p>The rest of the sections in this chapter discusses each of the
      major helper classes in detail. Please refer to the sample application
      that ships with Spring for additional hands-on usage.</p>

      <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        <p>To simplify documenting features that are common across all
        provider implementations of Spring's helper classes a specific
        provider, Apache ActiveMQ, was selected. As such when you see
        'NmsTemplate' in the documentation, it also refers to EmsTemplate,
        XmsTemplate, etc. unless specifically documented otherwise. The
        provider specific API classes are typically named after their JMS
        counterparts with the possible exception of a leading 'I' in front of
        interfaces in order to follow .NET naming conventions. In the
        documentation these API artifacts are referred to as
        'ConnectionFactory', 'Session', 'Message', etc. without the leading
        'I'.</p>
      </td></tr></table></div>

      <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        <p>To view some of this chapters contents that are based on TIBCO
        EMS please refer to the <a class="link" href="messaging-ems.html" title="Chapter&nbsp;32.&nbsp;Message Oriented Middleware - TIBCO EMS">TIBCO EMS
        chapter</a>.</p>
      </td></tr></table></div>
    </div>

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="activemq-intro-soc"></a>31.1.2.&nbsp;Separation of Concerns</h3></div></div></div>
      

      <p>The use of MessageConverters and a POCO programming model promote
      messaging best practices by applying the principal of Separation of
      Concerns to messaging based architectures. The infrastructure concern of
      publishing and consuming messages is separated from the concern of
      business processing. These two concerns are reflected in the
      architecture as two distinct layers, a message processing layer and a
      business processing layer. The benefit of this approach is that your
      business processing is decoupled from the messaging technology, making
      it more likely to survive technological changes over time and also
      easier to test. Spring's MessageConverters provides support for mapping
      messaging data types to POCOs. Aside from being the link between the two
      layers, MessageConverters provide a pluggable strategy to help support
      the evolution of a loosely coupled architecture over time. Message
      formats will change over time, typically by the addition of new fields.
      MessageConverters can be implemented to detect different versions of
      messages and perform the appropriate mapping logic to POCOs such so that
      multiple versions of a message can be supported simultaneously, a common
      requirement in enterprise messaging architectures.</p>
    </div>

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="activemq-intro-interop"></a>31.1.3.&nbsp;Interoperability and provider portability</h3></div></div></div>
      

      <p>Messaging is a traditional area of Interoperability across
      heterogeneous systems with messaging vendors providing support on
      multiple operating systems (Windows, UNIX, Mainframes OS's) as well as
      multiple language bindings (C, C++, Java, .NET, Perl, etc.). In 199x the
      Java Community Process came up with a specification to provide a common
      API across messaging providers as well as define some common messaging
      functionality. This specification is know as the Java Message Service.
      From the API perspective, it can roughly be thought of as the messaging
      counterpart to the ADO.NET or JDBC APIs that provide portability across
      different database providers.</p>

      <p>Given this history, when messaging vendors created their .NET
      APIs, many did so by creating their own JMS inspired API in .NET. There
      is no de facto-standard common API across messaging vendors. As such,
      portability across vendors using Spring's helper classes is done by
      changing the configuration schema in your configuration to a particular
      vendor and doing a 'search-and-replace' on the code base, changing the
      namespace and a few class names. While not ideal ,using Spring will push
      you in the direction of isolating the messaging specific classes in its
      own layer and therefore will reduce the impact of the changes you make
      to the code when switch providers. You business logic classes called
      into via Spring's messaging infrastructure will remain the same.</p>

      <p>The NMS project from Apache addresses the lack of a common API
      across .NET messaging providers by providing an abstract interface based
      API for messaging and several implementations for different providers.
      At the time of this writing, the project is close to releasing a 1.0
      version that supports ApacheMQ, MSMQ, and TIBCO EMS. There are a few
      outstanding issues at the moment that prevent one using NMS as a common
      API for all messaging providers but hopefully these issues will be
      resolved. Note, that NMS serves 'double' duty as the preferred API for
      messaging with ActiveMQ as well as a providing portability across
      different messaging providers.</p>
    </div>

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="activemq-intro-wcf"></a>31.1.4.&nbsp;The role of Messaging API in a 'WCF world'</h3></div></div></div>
      

      <p>Windows Communication Foundation (WCF) also supports message
      oriented middleware. Not surprisingly, a Microsoft Message Queuing
      (MSMQ) binding is provided as part of WCF. The WCF programming model is
      higher level than the traditional messaging APIs such as JMS and NMS
      since you are programing to a service interface and use metadata (either
      XML or attributes) to configure the messaging behavior. If you prefer to
      use this service-oriented, RPC style approach, then look to see if a
      vendor provides a WCF binding for your messaging provider. Note that
      even with the option of using WCF, many people prefer to sit 'closer to
      the metal' when using messaging middleware, to access specific features
      and functionality not available in WCF, or simply because they are more
      comfortable with that programming model.</p>

      <p>A WCF binding for Apache NMS is being developed as a separate
      project under the <a class="link" href="http://www.springframework.org/extensions/faq" target="_top">Spring
      Extensions</a> umbrella project. Stay tuned for details.</p>
    </div>
  </div>

  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="activemq-using"></a>31.2.&nbsp;Using Spring Messaging</h2></div></div></div>
    

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="activemq-using-messagetemplate"></a>31.2.1.&nbsp;Messaging Template overview</h3></div></div></div>
      

      <p>Code that uses the messaging template classes
      (<code class="literal">NmsTemplate</code>, <code class="literal">EmsTemplate</code>, etc)
      only needs to implement callback interfaces giving them a clearly
      defined contract. The <code class="literal">IMessageCreator</code> callback
      interface creates a message given a Session provided by the calling code
      in <code class="literal">NmsTemplate</code>. In order to allow for more complex
      usage of the provider messaging API, the callback
      <code class="literal">ISessionCallback</code> provides the user with the provider
      specific messaging Session and the callback
      <code class="literal">IProducerCallback</code> exposes a provider specific Session
      and MessageProducer pair. See <a class="xref" href="messaging.html#messaging-session-callback" title="31..&nbsp;Session and Producer Callback">Section&nbsp;31., &#8220;Session and Producer Callback&#8221;</a>.</p>

      <p>Provider messaging APIs typically expose two types of send
      methods, one that takes delivery mode, priority, and time-to-live as
      quality of service (QOS) parameters and one that takes no QOS parameters
      which uses default values. Since there are many higher level send
      methods in <code class="literal">NmsTemplate</code>, the setting of the QOS
      parameters have been exposed as properties on the template class to
      avoid duplication in the number of send methods. Similarly, the timeout
      value for synchronous receive calls is set using the property
      <code class="literal">ReceiveTimeout</code>.</p>

      <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        <p>Instances of the <code class="literal">NmsTemplate</code> class are
        thread-safe once configured. This is important because it means that
        you can configure a single instance of a
        <code class="literal">NmsTemplate</code> and then safely inject this shared
        reference into multiple collaborators. To be clear, the
        <code class="literal">NmsTemplate</code> is stateful, in that it maintains a
        reference to a <code class="literal">ConnectionFactory</code>, but this state is
        not conversational state.</p>
      </td></tr></table></div>
    </div>

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="activemq-using-connections"></a>31.2.2.&nbsp;Connections</h3></div></div></div>
      

      <p>The <code class="literal">NmsTemplate</code> requires a reference to a
      ConnectionFactory. The ConnectionFactory serves as the entry point for
      working with the provider's messaging API. It is used by the client
      application as a factory to create connections to the messaging server
      and encapsulates various configuration parameters, many of which are
      vendor specific such as SSL configuration options.</p>

      <p>To create a ActivfeMQ ConnectionFactory define can create an
      object definition as shown</p>

      <pre class="programlisting">  &lt;object id="nmsConnectionFactory" type="Apache.NMS.ActiveMQ.ConnectionFactory, Apache.NMS.ActiveMQ"&gt;
    &lt;constructor-arg index="0" value="tcp://localhost:61616"/&gt;
  &lt;/object&gt;</pre>

      <p><span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">EmsTemplate</span> also requres a reference to a
      ConnectionFactory, however, it is not the 'native'
      <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">TIBCO.EMS.ConnectionFactory</span>. Instead the
      connection factory type is
      Spring.Messaging.Ems.Common.IConnectionFactory. See the documentation
      for TIBCO EMS supper for more information <a class="link" href="messaging-ems.html" title="Chapter&nbsp;32.&nbsp;Message Oriented Middleware - TIBCO EMS">here</a>.</p>
    </div>

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="activemq-using-caching-resources"></a>31.2.3.&nbsp;Caching Messaging Resources</h3></div></div></div>
      

      <p>The standard API usage of NMS and other JMS inspired APIs involves
      creating many intermediate objects. To send a message the following
      'API' walk is performed</p>

      <pre class="programlisting">IConnectionFactory-&gt;IConnection-&gt;ISession-&gt;IMessageProducer-&gt;Send</pre>

      <p>Between the ConnectionFactory and the Send operation there are
      three intermediate objects that are created and destroyed. To optimise
      the resource usage and increase performance two implementations of
      IConnectionFactory are provided.</p>

      <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="activemq-using-caching-singleconnectionfactory"></a>31.2.3.1.&nbsp;SingleConnectionFactory</h4></div></div></div>
        

        <p><code class="literal">Spring.Messaging.Nms.Connections.SingleConnectionFactory
        </code>will return the same connection on all calls to
        CreateConnection and ignore calls to Close.</p>
      </div>

      <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="activemq-using-caching-cachingconnectionfactory"></a>31.2.3.2.&nbsp;CachingConnectionFactory</h4></div></div></div>
        

        <p><code class="literal">Spring.Messaging.Nms.Connections.CachingConnectionFactory</code>
        extends the functionality of SingleConnectionFactory and adds the
        caching of Sessions, MessageProducers, and MessageConsumers.</p>

        <p>The initial cache size is set to 1, use the property
        <code class="literal">SessionCacheSize</code> to increase the number of cached
        sessions. Note that the number of actual cached sessions will be more
        than that number as sessions are cached based on their acknowledgment
        mode, so there can be up to 4 cached session instances when
        SessionCacheSize is set to one, one for each
        <code class="literal">AcknowledgementMode</code>.
        <code class="literal">MessageProducers</code> and
        <code class="literal">MessageConsumers</code> are cached within their owning
        session and also take into account the unique properties of the
        producers and consumers when caching.</p>

        <p><code class="literal">MessageProducers</code> are cached based on their
        destination. <code class="literal">MessageConsumers</code> are cached based on a
        key composed of the destination, selector, noLocal delivery flag, and
        the durable subscription name (if creating durable consumers).</p>

        <p>Here is an example configuration</p>

        <pre class="programlisting">  &lt;object id="connectionFactory" type="Spring.Messaging.Nms.Connections.CachingConnectionFactory, Spring.Messaging.Nms"&gt;
    &lt;property name="SessionCacheSize" value="10" /&gt;
    &lt;property name="TargetConnectionFactory"&gt;
      &lt;object type="Apache.NMS.ActiveMQ.ConnectionFactory, Apache.NMS.ActiveMQ"&gt;
        &lt;constructor-arg index="0" value="tcp://localhost:61616"/&gt;
      &lt;/object&gt;
    &lt;/property&gt;
  &lt;/object&gt;
</pre>
      </div>
    </div>

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="activemq-using-destination-mgmt"></a>31.2.4.&nbsp;Dynamic Destination Management</h3></div></div></div>
      

      <p>In Java implementations of JMS, Connections and Destinations are
      'administered objects' accessible though JNDI - a directory service much
      like ActiveDirectory. In .NET each vendor has selected a different
      approach to destination management. Some are JNDI inspired, allowing you
      to retrieve Connections and Destinations that were configured
      administratively. You can use these vendor specific APIs to perform
      dependency injection on references to JMS Destination objects in
      Spring's XML configuration file by creating am implementation of
      <code class="literal">IObjectFactory</code> or alternatively configuring the
      specific concrete class implementation for a messaging provider.</p>

      <p>However, this approach of administered objects can be quite
      cumbersome if there are a large number of destinations in the
      application or if there are advanced destination management features
      unique to the messaging provider. Examples of such advanced destination
      management would be the creation of dynamic destinations or support for
      a hierarchical namespace of destinations. The
      <code class="literal">NmsTemplate</code> delegates the resolution of a destination
      name to a destination object by delegating to an implementation of the
      interface <code class="literal">IDestinationResolver</code>.
      <code class="literal">DynamicDestinationResolver</code> is the default
      implementation used by <code class="literal">NmsTemplate</code> and accommodates
      resolving dynamic destinations.</p>

      <p>Quite often the destinations used in a messaging application are
      only known at runtime and therefore cannot be administratively created
      when the application is deployed. This is often because there is shared
      application logic between interacting system components that create
      destinations at runtime according to a well-known naming convention.
      Even though the creation of dynamic destinations are not part of the
      original JMS specification, most vendors have provided this
      functionality. Dynamic destinations are created with a name defined by
      the user which differentiates them from temporary destinations and are
      often not registered in a directory service. The API used to create
      dynamic destinations varies from provider to provider since the
      properties associated with the destination are vendor specific. However,
      a simple implementation choice that is sometimes made by vendors is to
      use the <code class="literal">TopicSession</code> method
      <code class="literal">CreateTopic(string topicName)</code> or the
      <code class="literal">QueueSession</code> method <code class="literal">CreateQueue(string
      queueName)</code> to create a new destination with default
      destination properties. Depending on the vendor implementation,
      <code class="literal">DynamicDestinationResolver</code> may then also create a
      physical destination instead of only resolving one.</p>

      <p>The boolean property <code class="literal">PubSubDomain</code> is used to
      configure the <code class="literal">NmsTemplate</code> with knowledge of what
      messaging 'domain' is being used. By default the value of this property
      is false, indicating that the point-to-point domain, Queues, will be
      used. This property is infrequently used as the provider messaging APIs
      are now largely agnostic as to which messaging 'domain' is used,
      referring to 'Destinations' rather than 'Queues' or 'Topics'. However,
      this property does influence the behavior of dynamic destination
      resolution via implementations of the
      <code class="literal">IDestinationResolver</code> interface.</p>

      <p>You can also configure the <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">NmsTemplate</span> with
      a default destination via the property
      <code class="literal">DefaultDestination</code>. The default destination will be
      used with send and receive operations that do not refer to a specific
      destination.</p>
    </div>

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="activemq-listener-containers"></a>31.2.5.&nbsp;Message Listener Containers</h3></div></div></div>
      

      <p>One of the most common uses of JMS is to concurrently process
      messages delivered asynchronously. A message listener container is used
      to receive messages from a message queue and drive the
      <code class="literal">IMessageListener</code> that is injected into it. The
      listener container is responsible for all threading of message reception
      and dispatches into the listener for processing. A message listener
      container is the intermediary between an Message-Driven POCO (MDP) and a
      messaging provider, and takes care of registering to receive messages,
      resource acquisition and release, exception conversion and suchlike.
      This allows you as an application developer to write the (possibly
      complex) business logic associated with receiving a message (and
      possibly responding to it), and delegates boilerplate messaging
      infrastructure concerns to the framework.</p>

      <p>A subclass of <code class="literal">AbstractMessageListenerContainer</code>
      is used to receive messages from JMS and drive the Message-Driven POCOs
      (MDPs) that are injected into it. There are one subclasses of
      <code class="literal">AbstractMessageListenerContainer</code> packaged with Spring
      - <code class="literal">SimpleMessageListenerContainer</code>. Additional
      subclasses, in particular to participate in distributed transactions (if
      the provider supports it), will be provided in future releases.
      SimpleMessageListenerContainer creates a fixed number of JMS sessions at
      startup and uses them throughout the lifespan of the container.</p>

      <p>Creating and configuring a ActiveMQ MessageListener container is
      described in <a class="link" href="messaging.html#activemq-async-reception" title="31.5.2.&nbsp;Asynchronous Reception">this</a>
      section.</p>
    </div>

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="activemq-using-txmgmt"></a>31.2.6.&nbsp;Transaction Management</h3></div></div></div>
      

      <p>Spring provides an implementation of the
      IPlatformTransactionManager interface for managing ActiveMQ messaging
      transactions. The class is <code class="literal">NmsTransactionManager</code> and
      it manages transactions for a single ConnectionFactory. This allows
      messaging applications to leverage the managed transaction features of
      Spring as described in <a class="xref" href="transaction.html" title="Chapter&nbsp;17.&nbsp;Transaction management">Chapter&nbsp;17, <i>Transaction management</i></a>. The
      <code class="literal">NmsTransactionManager</code> performs local resource
      transactions, binding a Connection/Session pair from the specified
      ConnectionFactory to the thread. <code class="literal">NmsTemplate</code>
      automatically detects such transactional resources and operates on them
      accordingly.</p>

      <p>Using Spring's <code class="literal">SingleConnectionFactory</code> will
      result in a shared Connection, with each transaction having its own
      independent Session.</p>
    </div>
  </div>

  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="activemq-sending-messages"></a>31.3.&nbsp;Sending a Message</h2></div></div></div>
    

    <p>The <code class="literal">NmsTemplate</code> contains three convenience
    methods to send a message. The methods are listed below.</p>

    <div class="itemizedlist"><ul type="disc"><li>
        <p><code class="literal">void Send(IDestination destination, IMessageCreator
        messageCreator)</code></p>
      </li><li>
        <p><code class="literal">void Send(string destinationName, IMessageCreator
        messageCreator)</code></p>
      </li><li>
        <p><code class="literal">void Send(IMessageCreator
        messageCreator)</code></p>
      </li></ul></div>

    <p>The method differ in how the destination is specified. In first case
    the JMS Destination object is specified directly. The second case
    specifies the destination using a string that is then resolved to a
    messaging <code class="literal">Destination</code> object using the
    <code class="literal">IDestinationResolver</code> associated with the template. The
    last method sends the message to the destination specified by
    <code class="literal">NmsTemplate</code>''s <code class="literal">DefaultDestination</code>
    property.</p>

    <p>All methods take as an argument an instance of
    <code class="literal">IMessageCreator</code> which defines the API contract for you
    to create the JMS message. The interface is show below</p>

    <pre class="programlisting"><span style="color: #0000FF">public</span> <span style="color: #0000FF">interface</span> IMessageCreator {        
  IMessage CreateMessage(ISession session);
}</pre><p>Intermediate Sessions and MessageProducers needed to send
    the message are managed by <code class="literal">NmsTemplate</code>. The session
    passed in to the method is never null. There is a similar set methods that
    use a delegate instead of the interface, which can be convenient when
    writing small implementation in .NET 2.0 using anonymous delegates.
    Larger, more complex implementations of the method 'CreateMessage' are
    better suited to an interface based implementation.</p>

    <div class="itemizedlist"><ul type="disc"><li>
        <p><code class="literal">void SendWithDelegate(IDestination destination,
        MessageCreatorDelegate messageCreatorDelegate)</code></p>
      </li><li>
        <p><code class="literal">void SendWithDelegate(string destinationName,
        MessageCreatorDelegate messageCreatorDelegate)</code></p>
      </li><li>
        <p><code class="literal">void SendWithDelegate(MessageCreatorDelegate
        messageCreatorDelegate)</code></p>
      </li></ul></div>

    <p>The declaration of the delegate is</p>

    <pre class="programlisting"><span style="color: #0000FF">public</span> <span style="color: #0000FF">delegate</span> IMessage MessageCreatorDelegate(ISession session);</pre>

    <p>The following class shows how to use the SendWithDelegate method
    with an anonymous delegate to create a MapMessage from the supplied
    Session object. The use of the anonymous delegate allows for very terse
    syntax and easy access to local variables. The
    <code class="literal">NmsTemplate</code> is constructed by passing a reference to a
    ConnectionFactory.</p>

    <pre class="programlisting">    <span style="color: #0000FF">public</span> <span style="color: #0000FF">class</span> SimplePublisher
    {
        <span style="color: #0000FF">private</span> NmsTemplate template;
        
        <span style="color: #0000FF">public</span> SimplePublisher()
        {
            template = <span style="color: #0000FF">new</span> NmsTemplate(<span style="color: #0000FF">new</span> ConnectionFactory(<span style="color: #A31515">"tcp://localhost:61616"</span>));
        }
        
        <span style="color: #0000FF">public</span> <span style="color: #0000FF">void</span> Publish(<span style="color: #0000FF">string</span> ticker, <span style="color: #0000FF">double</span> price)
        {
            template.SendWithDelegate(<span style="color: #A31515">"APP.STOCK.MARKETDATA"</span>,
                          <span style="color: #0000FF">delegate</span>(ISession session)
                          {
                              IMapMessage message = session.CreateMapMessage();
                              message.Body.SetString(<span style="color: #A31515">"TICKER"</span>, ticker);
                              message.Body.SetDouble(<span style="color: #A31515">"PRICE"</span>, price);
                              message.NMSPriority = MsgPriority.Low;
                              <span style="color: #0000FF">return</span> message;
                          });
        }
    }


</pre>

    <p>A zero argument constructor and ConnectionFactory property are also
    provided. Alternatively consider deriving from Spring's
    <code class="literal">NmsGatewaySupport</code> convenience base class which provides
    a ConnectionFactory property that will instantiate a NmsTemplate instance
    that is made available via the property NmsTemplate.</p>

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="activemq-messageconverter"></a>31.3.1.&nbsp;Using MessageConverters</h3></div></div></div>
      

      <p>In order to facilitate the sending of domain model objects, the
      <code class="literal">NmsTemplate</code> has various send methods that take a .NET
      object as an argument for a message's data content. The overloaded
      methods <code class="literal">ConvertAndSend</code> and
      <code class="literal">ReceiveAndConvert</code> in <code class="literal">NmsTemplate</code>
      delegate the conversion process to an instance of the
      <code class="literal">IMessageConverter</code> interface. This interface defines a
      simple contract to convert between .NET objects and JMS messages. The
      default implementation <code class="literal">SimpleMessageConverter</code>
      supports conversion between <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">String</span> and
      <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">TextMessage</span>, <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">byte[]</span> and
      <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">BytesMesssage</span>, and
      <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">System.Collections.IDictionary</span> and
      <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">MapMessage</span>. By using the converter, you and your
      application code can focus on the business object that is being sent or
      received via messaging and not be concerned with the details of how it
      is represented as a JMS message. There is also an
      <code class="literal">XmlMessageConverter</code> that converts objects to an XML
      string and vice-versa for sending via a TextMessage. Please refer to the
      API documentation and example application for more information on
      configuring an <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">XmlMessageConverter</span>.</p>

      <p>The family of <code class="literal">ConvertAndSend</code> messages are
      similar to that of the Send method with the additional argument of type
      <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">IMessagePostProcessor</span>. These methods are
      listed below.</p>

      <div class="itemizedlist"><ul type="disc"><li>
          <p><code class="code">void ConvertAndSend(object message)</code></p>
        </li><li>
          <p><code class="code">void ConvertAndSend(object message,
          IMessagePostProcessor postProcessor)</code></p>
        </li><li>
          <p><code class="code">void ConvertAndSend(string destinationName, object
          message)</code></p>
        </li><li>
          <p><code class="code">void ConvertAndSend(string destinationName, object
          message, IMessagePostProcessor postProcessor);</code></p>
        </li><li>
          <p><code class="code">void ConvertAndSend(Destination destination, object
          message)</code></p>
        </li><li>
          <p><code class="code">void ConvertAndSend(Destination destination, object
          message, IMessagePostProcessor postProcessor)</code></p>
        </li></ul></div>

      <p>The example below uses the default message converter to send a
      Hashtable as a message to the destination "APP.STOCK".</p>

      <pre class="programlisting"><span style="color: #0000FF">public</span> <span style="color: #0000FF">void</span> PublishUsingDict(<span style="color: #0000FF">string</span> ticker, <span style="color: #0000FF">double</span> price)
{
  IDictionary marketData = <span style="color: #0000FF">new</span> Hashtable();
  marketData.Add(<span style="color: #A31515">"TICKER"</span>, ticker);
  marketData.Add(<span style="color: #A31515">"PRICE"</span>, price);
  template.ConvertAndSend(<span style="color: #A31515">"APP.STOCK.MARKETDATA"</span>, marketData);
}</pre><p>To accommodate the setting of message's properties, headers,
      and body that can not be generally encapsulated inside a converter
      class, the <code class="literal">IMessageConverterPostProcessor</code> interface
      gives you access to the message after it has been converted but before
      it is sent. The example below demonstrates how to modify a message
      header and a property after a Hashtable is converted to a message using
      the IMessagePostProcessor. The methods
      <code class="literal">ConvertAndSendUsingDelegate</code> allow for the use of a
      delegate to perform message post processing. This family of methods is
      listed below</p>

      <div class="itemizedlist"><ul type="disc"><li>
          <p><code class="literal">void ConvertAndSendWithDelegate(object message,
          MessagePostProcessorDelegate postProcessor)</code></p>
        </li><li>
          <p><code class="literal">void ConvertAndSendWithDelegate(IDestination
          destination, object message, MessagePostProcessorDelegate
          postProcessor)</code></p>
        </li><li>
          <p><code class="literal">void ConvertAndSendWithDelegate(string
          destinationName, object message, MessagePostProcessorDelegate
          postProcessor)</code></p>
        </li></ul></div>

      <p>The declaration of the delegate is</p>

      <pre class="programlisting"><span style="color: #0000FF">public</span> <span style="color: #0000FF">delegate</span> IMessage MessagePostProcessorDelegate(IMessage message);</pre>

      <p>The following code shows this in action.</p>

      <pre class="programlisting"><span style="color: #0000FF">public</span> <span style="color: #0000FF">void</span> PublishUsingDict(<span style="color: #0000FF">string</span> ticker, <span style="color: #0000FF">double</span> price)
{
  IDictionary marketData = <span style="color: #0000FF">new</span> Hashtable();
  marketData.Add(<span style="color: #A31515">"TICKER"</span>, ticker);
  marketData.Add(<span style="color: #A31515">"PRICE"</span>, price);
  template.ConvertAndSendWithDelegate(<span style="color: #A31515">"APP.STOCK.MARKETDATA"</span>, marketData, 
           <span style="color: #0000FF">delegate</span>(IMessage message)
           { 
             message.NMSPriority = MsgPriority.Low;
             message.NMSCorrelationID = <span style="color: #0000FF">new</span> Guid().ToString();
             <span style="color: #0000FF">return</span> message;
           });
}</pre>
    </div>
  </div>

  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="messaging-session-callback"></a>31..&nbsp;Session and Producer Callback</h2></div></div></div>
    

    <p>While the send operations cover many common usage scenarios, there
    are cases when you want to perform multiple operations on a JMS Session or
    MessageProducer. The SessionCallback and ProducerCallback expose the
    Session and Session / MessageProducer pair respectfully. The Execute()
    methods on NmsTemplate execute these callback methods.</p>

    <div class="itemizedlist"><ul type="disc"><li>
        <p><code class="code">public object Execute(IProducerCallback
        action)</code></p>
      </li><li>
        <p><code class="literal">public object Execute(ProducerDelegate
        action)</code></p>
      </li><li>
        <p><code class="code">public object Execute(ISessionCallback
        action)</code></p>
      </li><li>
        <p><code class="literal">public object Execute(SessionDelegate
        action)</code></p>
      </li></ul></div>

    <p>Where ISessionCallback and IProducerCallback are</p>

    <pre class="programlisting"><span style="color: #0000FF">public</span> <span style="color: #0000FF">interface</span> IProducerCallback
{
    <span style="color: #0000FF">object</span> DoInNms(ISession session, IMessageProducer producer);
}</pre><p>and</p>

    <pre class="programlisting"><span style="color: #0000FF">public</span> <span style="color: #0000FF">interface</span> ISessionCallback
{
    <span style="color: #0000FF">object</span> DoInNms(ISession session);
}</pre>

    <p>The delegate signatures are listed below and mirror the interface
    method signature</p>

    <pre class="programlisting"><span style="color: #0000FF">public</span> <span style="color: #0000FF">delegate</span> <span style="color: #0000FF">object</span> SessionDelegate(ISession session);

<span style="color: #0000FF">public</span> <span style="color: #0000FF">delegate</span> <span style="color: #0000FF">object</span> ProducerDelegate(ISession session, IMessageProducer producer);</pre>
  </div>

  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e8957"></a>31.5.&nbsp;Receiving a message</h2></div></div></div>
    

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="activemq-sync-receive"></a>31.5.1.&nbsp;Synchronous Reception</h3></div></div></div>
      

      <p>While messaging middleware is typically associated with
      asynchronous processing, it is possible to consume messages
      synchronously. The overloaded <code class="code">Receive(..)</code> methods on
      <code class="literal">NmsTemplate</code> provide this functionality. During a
      synchronous receive, the calling thread blocks until a message becomes
      available. This can be a dangerous operation since the calling thread
      can potentially be blocked indefinitely. The property
      <code class="code"><span class="property">ReceiveTimeout</span></code> on
      <code class="literal">NmsTemplate</code> specifies how long the receiver should
      wait before giving up waiting for a message.</p>

      <p>The <code class="methodname">Receive</code> methods are listed
      below</p>

      <div class="itemizedlist"><ul type="disc"><li>
          <p><code class="code">public Message Receive()</code></p>
        </li><li>
          <p><code class="code">public Message Receive(Destination
          destination)</code></p>
        </li><li>
          <p><code class="code">public Message Receive(string
          destinationName)</code></p>
        </li><li>
          <p><code class="code">public Message ReceiveSelected(string
          messageSelector)</code></p>
        </li><li>
          <p><code class="code">public Message ReceiveSelected(string destinationName,
          string messageSelector)</code></p>
        </li><li>
          <p><code class="code">public Message ReceiveSelected(Destination destination,
          string messageSelector)</code></p>
        </li></ul></div>

      <p>The <code class="methodname">Receive</code> method without arguments will
      use the <span class="property">DefaultDestination</span>. The
      <code class="methodname">ReceiveSelected</code> methods apply the provided
      message selector string to the <code class="literal">MessageConsumer</code> that
      is created.</p>

      <p>The <code class="methodname">ReceiveAndConvert</code> methods apply the
      template's message converter when receiving a message. The message
      converter to use is set using the property
      <code class="literal">MessageConverter</code> and is the
      <code class="literal">SimpleMessageConverter</code> implementation by default.
      These methods are listed below.</p>

      <div class="itemizedlist"><ul type="disc"><li>
          <p><code class="code">public object ReceiveAndConvert()</code></p>
        </li><li>
          <p><code class="code">public object ReceiveAndConvert(Destination
          destination)</code></p>
        </li><li>
          <p><code class="code">public object ReceiveAndConvert(string
          destinationName)</code></p>
        </li><li>
          <p><code class="code">public object ReceiveSelectedAndConvert(string
          messageSelector)</code></p>
        </li><li>
          <p><code class="code">public object ReceiveSelectedAndConvert(string
          destinationName, string messageSelector)</code></p>
        </li><li>
          <p><code class="code">public object ReceiveSelectedAndConvert(Destination
          destination, string messageSelector)</code></p>
        </li></ul></div>
    </div>

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="activemq-async-reception"></a>31.5.2.&nbsp;Asynchronous Reception</h3></div></div></div>
      

      <p>Asynchronous reception of messages occurs by the messaging
      provider invoking a callback function. This is commonly an interface
      such as the <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">IMessageListener</span> interface
      shown below, taken from the TIBCO EMS provider.</p>

      <pre class="programlisting"><span style="color: #0000FF">public</span> <span style="color: #0000FF">interface</span> IMessageListener
{
      <span style="color: #0000FF">void</span> OnMessage(Message message);
}</pre>

      <p>Other vendors may provide a delegate based version of this
      callback or even both a delegate and interface options. Apache ActiveMQ
      supports the use of delegates for message reception callbacks. As a
      programming convenience in <code class="literal">Spring.Messaging.Nms.Core</code>
      is an interface <code class="literal">IMessageListener</code> that can be used
      with NMS.</p>

      <p>Below is a simple implementation of the
      <code class="literal">IMessageListener</code> interface that processes a
      message.</p>

      <pre class="programlisting"><span style="color: #0000FF">using</span> Spring.Messaging.Nms.Core;
<span style="color: #0000FF">using</span> Apache.NMS;
<span style="color: #0000FF">using</span> Common.Logging;

<span style="color: #0000FF">namespace</span> MyApp
{
  <span style="color: #0000FF">public</span> <span style="color: #0000FF">class</span> SimpleMessageListener : IMessageListener
  {
        <span style="color: #0000FF">private</span> <span style="color: #0000FF">static</span> <span style="color: #0000FF">readonly</span> ILog LOG = LogManager.GetLogger(<span style="color: #0000FF">typeof</span>(SimpleMessageListener));

        <span style="color: #0000FF">private</span> <span style="color: #0000FF">int</span> messageCount;

        <span style="color: #0000FF">public</span> <span style="color: #0000FF">int</span> MessageCount
        {
            <span style="color: #0000FF">get</span> { <span style="color: #0000FF">return</span> messageCount; }
        }

        <span style="color: #0000FF">public</span> <span style="color: #0000FF">void</span> OnMessage(IMessage message)
        {           
            messageCount++;
            LOG.Debug(<span style="color: #A31515">"Message listener count = "</span> + messageCount);
            ITextMessage textMessage = message <span style="color: #0000FF">as</span> ITextMessage;
            <span style="color: #0000FF">if</span> (textMessage != <span style="color: #0000FF">null</span>)
            {
                LOG.Info(<span style="color: #A31515">"Message Text = "</span> + textMessage.Text);
            } <span style="color: #0000FF">else</span>
            {
                LOG.Warn(<span style="color: #A31515">"Can not process message of type "</span> message.GetType());
            }
        }
}</pre>

      <p>Once you've implemented your message listener, it's time to create
      a message listener container.</p>

      <p>You register you listener with a message listener container that
      specifies various messaging configuration parameters, such as the
      ConnectionFactory, and the number of concurrent consumers to create.
      There is an abstract base class for message listener containers,
      <code class="literal">AbstractMessageListenerContainer</code>, and one concrete
      implementation, <code class="literal">SimpleMessageListenerContainer</code>.
      <code class="literal">SimpleMessageListenerContainer</code> creates a fixed number
      of JMS Sessions/MessageConsumer pairs as set by the property
      <span class="property">ConcurrentConsumers</span>. The default value of
      ConcurrentConsumers is one. Here is a sample configuration that uses the
      the custom schema provided in Spring.NET to more reasily configure
      MessageListenerContainers.</p>

      <pre class="programlisting"><span style="color: #A31515">&lt;objects</span> <span style="color: #FF0000">xmlns</span>=<span style="color: #0000FF">"http://www.springframework.net"</span>
         <span style="color: #FF0000">xmlns:nms</span>=<span style="color: #0000FF">"http://www.springframework.net/nms"</span><span style="color: #A31515">&gt;</span>

  <span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"ActiveMqConnectionFactory"</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Apache.NMS.ActiveMQ.ConnectionFactory, Apache.NMS.ActiveMQ"</span><span style="color: #A31515">&gt;</span>
    <span style="color: #A31515">&lt;constructor-arg</span> <span style="color: #FF0000">index</span>=<span style="color: #0000FF">"0"</span> <span style="color: #FF0000">value</span>=<span style="color: #0000FF">"tcp://localhost:61616"</span><span style="color: #A31515">/&gt;</span>
  <span style="color: #A31515">&lt;/object&gt;</span>

  <span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"ConnectionFactory"</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Messaging.Nms.Connections.CachingConnectionFactory, Spring.Messaging.Nms"</span><span style="color: #A31515">&gt;</span>
    <span style="color: #A31515">&lt;constructor-arg</span> <span style="color: #FF0000">index</span>=<span style="color: #0000FF">0"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"ActiveMqConnectionFactory"</span><span style="color: #A31515">/&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"SessionCacheSize"</span> <span style="color: #FF0000">value</span>=<span style="color: #0000FF">"10"</span><span style="color: #A31515">/&gt;</span>
  <span style="color: #A31515">&lt;/object&gt;</span>

  <span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"MyMessageListener"</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"MyApp.SimpleMessageListener, MyApp"</span><span style="color: #A31515">/&gt;</span>

  <span style="color: #A31515">&lt;nms:listener-container</span> <span style="color: #FF0000">connection-factory</span>=<span style="color: #0000FF">"ConnectionFactory"</span> <span style="color: #FF0000">concurrency</span>=<span style="color: #0000FF">"10"</span><span style="color: #A31515">&gt;</span>
    <span style="color: #A31515">&lt;nms:listener</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"MyMessageListener"</span> <span style="color: #FF0000">destination</span>=<span style="color: #0000FF">"APP.STOCK.REQUEST"</span><span style="color: #A31515"> /&gt;</span>
  <span style="color: #A31515">&lt;/nms:listener-container&gt;</span>

<span style="color: #A31515">&lt;/objects&gt;</span></pre>

      <p>The above configuration will create 10 threads that process
      messages off of the queue named "APP.STOCK.REQUEST". The threads are
      those owned by the messaging provider as a result of creating a
      MessageConsumer. Other important properties are
      <span class="property">ClientID</span>, used to set the ClientID of the
      Connection and <span class="property">MessageSelector</span> to specify the
      'sql-like' message selector string. Durable subscriptions are supported
      via the properties <span class="property">SubscriptionDurable</span> and
      <span class="property">DurableSubscriptionName</span>. You may also register an
      exception listener using the property
      <code class="literal">ExceptionListener</code>.</p>

      <p>Exceptions that are thrown during message processing can be passed
      to an implementation of <code class="literal">IExceptionHandler</code> and
      registered with the container via the property
      <code class="literal">ExceptionListener</code>. The registered
      <code class="literal">IExceptionHandler</code> will be invoked if the exception is
      of the type <code class="literal">NMSException</code> (or the equivalent root
      exception type for other providers). The SimpleMessageListenerContainer
      will logs the exception at error level and not propagate the exception
      to the provider. All handling of acknowledgement and/or transactions is
      done by the listener container. You can override the method
      <code class="literal">HandleListenerException</code> to change this
      behavior.</p>

      <p>Please refer to the Spring SDK documentation for additional
      description of the features and properties of
      <code class="literal">SimpleMessageListenerContainer</code>.</p>
    </div>

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="activemq-sessionaware"></a>31.5.3.&nbsp;The ISessionAwareMessageListener interface</h3></div></div></div>
      

      <p>The <code class="literal">ISessionAwareMessageListener</code> interface is a
      Spring-specific interface that provides a similar contract to the
      messaging provider's <code class="literal">IMessageListener</code> interface or
      Listener delegate/event, but also provides the message handling method
      with access to the Session from which the Message was received.</p>

      <pre class="programlisting"><span style="color: #0000FF">public</span> <span style="color: #0000FF">interface</span> ISessionAwareMessageListener
{        
   <span style="color: #0000FF">void</span> OnMessage(IMessage message, ISession session);
}</pre>

      <p>You can also choose to implement this interface and register it
      with the message listener container</p>
    </div>

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="message-listener-adapter"></a>31.5.4.&nbsp;MessageListenerAdapater</h3></div></div></div>
      

      <p>The MessageListenerAdapter class is the final component in
      Spring's asynchronous messaging support: in a nutshell, it allows you to
      expose almost any class to be invoked as a messaging callback (there are
      of course some constraints).</p>

      <p>Consider the following interface definition. Notice that although
      the interface extends neither the <code class="literal">IMessageListener</code>
      nor <code class="literal">ISessionAwareMessageListener</code> interfaces, it can
      still be used as a Message-Driven POCOs (MDP) via the use of the
      <code class="literal">MessageListenerAdapter</code> class. Notice also how the
      various message handling methods are strongly typed according to the
      contents of the various Message types that they can receive and
      handle.</p>

      <pre class="programlisting"><span style="color: #0000FF">public</span> <span style="color: #0000FF">interface</span> MessageHandler {

    <span style="color: #0000FF">void</span> HandleMessage(<span style="color: #0000FF">string</span> message);

    <span style="color: #0000FF">void</span> HandleMessage(Hashtable message);

    <span style="color: #0000FF">void</span> HandleMessage(<span style="color: #0000FF">byte</span>[] message);

}</pre>

      <p>and a class that implements this interface...</p>

      <pre class="programlisting"><span style="color: #0000FF">public</span> <span style="color: #0000FF">class</span> DefaultMessageHandler : IMessageHandler {
    <i style="color: #008000">// stub implementations elided for bevity...</i>
}</pre>

      <p>In particular, note how the above implementation of the
      IMessageHandler interface (the above DefaultMessageHandler class) has no
      messaging provider API dependencies at all. It truly is a POCO that we
      will make into an MDP via the following configuration.</p>

      <pre class="programlisting"><span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"MessagleHandler"</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"MyApp.DefaultMessageHandler, MyApp"</span><span style="color: #A31515">/&gt;</span>

<span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"MessageListenerAdapter"</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Messaging.Nms.Listener.Adapter.MessageListenerAdapter, Spring.Messaging.Nms"</span><span style="color: #A31515">&gt;</span>
  <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"HandlerObject"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"MessagleHandler"</span><span style="color: #A31515">/&gt;</span>
<span style="color: #A31515">&lt;/object&gt;</span>

<span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"MessageListenerContainer"</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Messaging.Nms.Listener.SimpleMessageListenerContainer, Spring.Messaging.Nms"</span><span style="color: #A31515">&gt;</span>
  <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"ConnectionFactory"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"ConnectionFactory"</span><span style="color: #A31515">/&gt;</span>
  <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"DestinationName"</span> <span style="color: #FF0000">value</span>=<span style="color: #0000FF">"APP.REQUEST"</span><span style="color: #A31515">/&gt;</span>
  <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"MessageListener"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"MessageListenerAdapter"</span><span style="color: #A31515">/&gt;</span>
<span style="color: #A31515">&lt;/object&gt;</span></pre>

      <p>The previous examples relies on the fact that the default
      IMessageConverter implementation of the MessageListenerAdapter is
      SimpleMessageConverter that can convert from messages to strings,
      byte[], and hashtables and object from a ITextMessage, IBytesMessage,
      IMapMessage, and IObjectMessage respectfully.</p>

      <p>Below is an example of another MDP that can only handle the
      receiving of NMS ITextMessage messages. Notice how the message handling
      method is actually called 'Receive' (the name of the message handling
      method in a MessageListenerAdapter defaults to 'HandleMessage'), but it
      is configurable (as you will see below). Notice also how the
      'Receive(..)' method is strongly typed to receive and respond only to
      NMS ITextMessage messages.</p>

      <pre class="programlisting"><span style="color: #0000FF">public</span> <span style="color: #0000FF">interface</span> TextMessageHandler {

    <span style="color: #0000FF">void</span> Receive(ITextMessage message);
}</pre>

      <pre class="programlisting"><span style="color: #0000FF">public</span> <span style="color: #0000FF">class</span> TextMessageHandler implements ITextMessageHandler {
    <i style="color: #008000">// implementation elided for clarity...</i>
}</pre>

      <p>The configuration of the attendant
      <code class="literal">MessageListenerAdapter</code> would look like this</p>

      <pre class="programlisting"><span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"MessagleHandler"</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"MyApp.DefaultMessageHandler, MyApp"</span><span style="color: #A31515">/&gt;</span>

<span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"MessageListenerAdapter"</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Messaging.Nms.Listener.Adapter.MessageListenerAdapter, Spring.Messaging.Nms"</span><span style="color: #A31515">&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"HandlerObject"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"TextMessagleHandler"</span><span style="color: #A31515">/&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"DefaultHandlerMethod"</span> <span style="color: #FF0000">value</span>=<span style="color: #0000FF">"Receive"</span><span style="color: #A31515">/&gt;</span>
    <i style="color: #008000">&lt;!-- we don't want automatic message context extraction --&gt;</i>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"MessageConverter"</span><span style="color: #A31515">&gt;</span>
        <span style="color: #A31515">&lt;null/&gt;</span>
    <span style="color: #A31515">&lt;/property&gt;</span>
<span style="color: #A31515">&lt;/object&gt;</span></pre>

      <p>Please note that if the above 'MessageListener' receives a Message
      of a type other than ITextMessage, a
      <code class="literal">ListenerExecutionFailedException</code> will be thrown (and
      subsequently handled by the container by logging the exception).</p>

      <p>If your <code class="literal">IMessageConverter</code> implementation will
      return multiple object types, overloading the handler method is
      perfectly acceptable, the most specific matching method will be used. A
      method with an object signature would be consider a 'catch-all' method
      of last resort. For example, you can have an handler interface as shown
      below.</p>

      <pre class="programlisting"><span style="color: #0000FF">public</span> <span style="color: #0000FF">interface</span> IMyHandler
{
   <span style="color: #0000FF">void</span> DoWork(<span style="color: #0000FF">string</span> text);
   <span style="color: #0000FF">void</span> DoWork(OrderRequest orderRequest);
   <span style="color: #0000FF">void</span> DoWork(InvoiceRequest invoiceRequest);
   <span style="color: #0000FF">void</span> DoWork(<span style="color: #0000FF">object</span> obj);
}</pre>

      <p>Another of the capabilities of the MessageListenerAdapter class is
      the ability to automatically send back a response Message if a handler
      method returns a non-void value. The adapter's message converter will be
      used to convert the methods return value to a message. The resulting
      message will then be sent to the Destination defined in the JMS Reply-To
      property of the original Message (if one exists) , or the default
      Destination set on the MessageListenerAdapter (if one has been
      configured). If no Destination is found then an
      <code class="literal">InvalidDestinationException</code> will be thrown (and
      please note that this exception will not be swallowed and will propagate
      up the call stack).</p>

      <p>An interface that is typical when used with a message converter
      that supports multiple object types and has return values is shown
      below.</p>

      <pre class="programlisting"><span style="color: #0000FF">public</span> <span style="color: #0000FF">interface</span> IMyHandler
{
   <span style="color: #0000FF">string</span> DoWork(<span style="color: #0000FF">string</span> text);
   OrderResponse DoWork(OrderRequest orderRequest);
   InvoiceResponse DoWork(InvoiceRequest invoiceRequest);
   <span style="color: #0000FF">void</span> DoWork(<span style="color: #0000FF">object</span> obj);
}</pre>

      <p></p>
    </div>

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="activemq-msg-tx"></a>31.5.5.&nbsp;Processing messages within a messaging transaction</h3></div></div></div>
      

      <p>Invoking a message listener within a transaction only requires
      reconfiguration of the listener container. Local message transactions
      can be activated by setting the property SessionAcknowledgeMode which
      for NMS is of the enum type AcknowledgementMode, to
      AcknowledgementMode.Transactional. Each message listener invocation will
      then operate within an active messaging transaction, with message
      reception rolled back in case of listener execution failure.</p>

      <p>Sending a response message (via ISessionAwareMessageListener) will
      be part of the same local transaction, but any other resource operations
      (such as database access) will operate independently. This usually
      requires duplicate message detection in the listener implementation,
      covering the case where database processing has committed but message
      processing failed to commit. See the discussion on the ActiveMQ web site
      <a class="ulink" href="http://activemq.apache.org/should-i-use-xa.html" target="_top">here</a> for
      more information combining local database and messaging
      transactions.</p>
    </div>

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="activemq-namespace"></a>31.5.6.&nbsp;Messaging Namespace support</h3></div></div></div>
      

      <p>To use the NMS namespace elements you will need to reference the
      NMS schema. When using TIBCO EMS you should refer to the TIBCO EMS
      Schema. For information on how to set this up refer to <a class="xref" href="xsd-config.html#xsd-config-body-schemas-nms" title="B.2.7.&nbsp;The nms messaging schema">Section&nbsp;B.2.7, &#8220;The nms messaging schema&#8221;</a>. The namespace consists of one
      top level elements: &lt;listener-container/&gt; which can contain one or
      more &lt;listener/&gt; child elements. Here is an example of a basic
      configuration for two listeners.</p>

      <pre class="programlisting"><span style="color: #A31515">&lt;nms:listener-container&gt;</span>

    <span style="color: #A31515">&lt;nms:listener</span> <span style="color: #FF0000">destination</span>=<span style="color: #0000FF">"queue.orders"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"OrderService"</span> <span style="color: #FF0000">method</span>=<span style="color: #0000FF">"PlaceOrder"</span><span style="color: #A31515">/&gt;</span>

    <span style="color: #A31515">&lt;nms:listener</span> <span style="color: #FF0000">destination</span>=<span style="color: #0000FF">"queue.confirmations"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"ConfirmationLogger"</span> <span style="color: #FF0000">method</span>=<span style="color: #0000FF">"Log"</span><span style="color: #A31515">/&gt;</span>

<span style="color: #A31515">&lt;/nms:listener-container&gt;</span></pre>

      <p>The example above is equivalent to creating two distinct listener
      container object definitions and two distinct MessageListenerAdapter
      object definitions as demonstrated in the section entitled <a class="xref" href="messaging.html#message-listener-adapter" title="31.5.4.&nbsp;MessageListenerAdapater">Section&nbsp;31.5.4, &#8220;MessageListenerAdapater&#8221;</a>. In addition to the attributes
      shown above, the listener element may contain several optional ones. The
      following table describes all available attributes:</p>

      <div class="table"><a name="nms-namespace-listener-tbl"></a><div class="title">Table&nbsp;31.1.&nbsp;Attributes of the NMS <code class="literal">&lt;listener&gt;</code>
        element</div><div class="table-contents">
        

        <table summary="Attributes of the NMS <listener&gt;&#xA;        element" border="1"><colgroup><col><col></colgroup><thead><tr><th>Attribute</th><th>Description</th></tr></thead><tbody><tr><td>id</td><td>
                <p>A object name for the hosting listener container. If not
                specified, a object name will be automatically
                generated.</p>
              </td></tr><tr><td>destination <span class="bold"><strong>(required)</strong></span></td><td>
                <p>The destination name for this listener, resolved through
                the <code class="literal">IDestinationResolver</code> strategy.</p>
              </td></tr><tr><td>ref <span class="bold"><strong>(required)</strong></span></td><td>
                <p>The object name of the handler object.</p>
              </td></tr><tr><td>method</td><td>
                <p>The name of the handler method to invoke. If the
                <code class="literal">ref</code> points to a
                <code class="literal">IMessageListener</code> or Spring
                <code class="literal">ISessionAwareMessageListener</code>, this
                attribute may be omitted.</p>
              </td></tr><tr><td>response-destination</td><td>
                <p>The name of the default response destination to send
                response messages to. This will be applied in case of a
                request message that does not carry a "NMSReplyTo" field. The
                type of this destination will be determined by the
                listener-container's "destination-type" attribute. Note: This
                only applies to a listener method with a return value, for
                which each result object will be converted into a response
                message.</p>
              </td></tr><tr><td>subscription</td><td>
                <p>The name of the durable subscription, if any.</p>
              </td></tr><tr><td>selector</td><td>
                <p>An optional message selector for this listener.</p>
              </td></tr><tr><td>pubsub-domain</td><td>
                <p>An optional boolean value. Set to true for the
                publish-subscribe domain (Topics) or false (the default) for
                point-to-point domain (Queues). This is useful when using the
                default implementation for destination resolvers.</p>
              </td></tr></tbody></table>
      </div></div><br class="table-break">

      <p>The &lt;listener-container/&gt; element also accepts several
      optional attributes. This allows for customization of the various
      strategies (for example, DestinationResolver) as well as basic messaging
      settings and resource references. Using these attributes, it is possible
      to define highly-customized listener containers while still benefiting
      from the convenience of the namespace.</p>

      <pre class="programlisting"><span style="color: #A31515">&lt;nms:listener-container</span> <span style="color: #FF0000">connection-factory</span>=<span style="color: #0000FF">"MyConnectionFactory"</span>
                        <span style="color: #FF0000">destination-resolver</span>=<span style="color: #0000FF">"MyDestinationResolver"</span>                        
                        <span style="color: #FF0000">concurrency</span>=<span style="color: #0000FF">"10"</span><span style="color: #A31515">&gt;</span>

    <span style="color: #A31515">&lt;nms:listener</span> <span style="color: #FF0000">destination</span>=<span style="color: #0000FF">"queue.orders"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"OrderService"</span> <span style="color: #FF0000">method</span>=<span style="color: #0000FF">"PlaceOrder"</span><span style="color: #A31515">/&gt;</span>

    <span style="color: #A31515">&lt;nms:listener</span> <span style="color: #FF0000">destination</span>=<span style="color: #0000FF">"queue.confirmations"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"ConfirmationLogger"</span> <span style="color: #FF0000">method</span>=<span style="color: #0000FF">"Log"</span><span style="color: #A31515">/&gt;</span>

<span style="color: #A31515">&lt;/nms:listener-container&gt;</span></pre>

      <p>The following table describes all available attributes. Consult
      the class-level SDK documentation of the
      <code class="literal">AbstractMessageListenerContainer</code> and its subclass
      <code class="literal">SimpleMessageListenerContainer</code> for more detail on the
      individual properties.</p>

      <div class="table"><a name="nms-namespace-listener-container-tbl"></a><div class="title">Table&nbsp;31.2.&nbsp;Attributes of the NMS
        <code class="literal">&lt;listener-container&gt;</code> element</div><div class="table-contents">
        

        <table summary="Attributes of the NMS&#xA;        <listener-container&gt; element" border="1"><colgroup><col><col></colgroup><thead><tr><th>Attribute</th><th>Description</th></tr></thead><tbody><tr><td>connection-factory</td><td>
                <p>A reference to the NMS
                <code class="literal">ConnectionFactory</code> object (the default
                object name is <code class="literal">'ConnectionFactory'</code>).</p>
              </td></tr><tr><td>destination-resolver</td><td>
                <p>A reference to the
                <code class="literal">IDestinationResolver</code> strategy for resolving
                JMS <code class="literal">Destinations</code>.</p>
              </td></tr><tr><td>message-converter</td><td>
                <p>A reference to the <code class="literal">IMessageConverter</code>
                strategy for converting NMS Messages to listener method
                arguments. Default is a
                <code class="literal">SimpleMessageConverter</code>.</p>
              </td></tr><tr><td>destination-type</td><td>
                <p>The NMS destination type for this listener:
                <code class="literal">queue</code>, <code class="literal">topic</code> or
                <code class="literal">durableTopic</code>. The default is
                <code class="literal">queue</code>.</p>
              </td></tr><tr><td>client-id</td><td>
                <p>The NMS client id for this listener container. Needs to
                be specified when using durable subscriptions.</p>
              </td></tr><tr><td>acknowledge</td><td>
                <p>The native NMS acknowledge mode:
                <code class="literal">auto</code>, <code class="literal">client</code>,
                <code class="literal">dups-ok</code> or <code class="literal">transacted</code>. A
                value of <code class="literal">transacted</code> activates a locally
                transacted <code class="literal">Session</code>. As an alternative,
                specify the <code class="literal">transaction-manager</code> attribute
                described below. Default is <code class="literal">auto</code>.</p>
              </td></tr><tr><td>concurrency</td><td>
                <p>The number of concurrent sessions/consumers to start for
                each listener. Default is 1; keep concurrency limited to 1 in
                case of a topic listener or if queue ordering is important;
                consider raising it for general queues.</p>
              </td></tr><tr><td>recovery-interval</td><td>
                <p>The time interval between connection recovery attempts.
                The default is 5 seconds. Specify as a TimeSpan value using
                Spring's TimeSpanConverter (e.g. 10s, 10m, 3h, etc)</p>
              </td></tr><tr><td>max-recovery-time</td><td>
                <p>The maximum time try reconnection attempts. The default
                is 10 minutes. Specify as a TimeSpan value using Spring's
                TimeSpanConverter (e.g. 10s, 10m, 3h, etc)</p>
              </td></tr><tr><td>auto-startup</td><td>Set whether to automatically start the listeners after
              initialization. Default is true, optionally set to
              false.</td></tr><tr><td>error-handler</td><td>A reference to a IErrorHandler that will handle any
              uncaught exceptions other than those of the type NMSException
              (in the case of ActiveMQ or EMSException int he case of TIBCO
              EMS) that may occur during the execution of the message
              listener. By default no ErrorHandler is registered and that
              error-level logging is the default behavior.</td></tr><tr><td>exception-listener</td><td>A reference to an
              Spring.Messaging.Nms.Core.IExceptionListener or
              TIBCO.EMS.IExceptionListener as appropriate. Is invokved in case
              of a NMSException or EMSException.</td></tr></tbody></table>
      </div></div><br class="table-break">
    </div>
  </div>
</div><div xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="navfooter"><hr></hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="spring-integration.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="messaging-ems.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Part&nbsp;V.&nbsp;Integration&nbsp;</td><td width="20%" align="center"><span style="color:white;font-size:90%;"><a href="http://www.springsource.com/" title="SpringSource">Sponsored by SpringSource</a></span></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;32.&nbsp;Message Oriented Middleware - TIBCO EMS</td></tr></table></div></body></html>